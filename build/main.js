var v=Object.defineProperty,me=Object.defineProperties,de=Object.getOwnPropertyDescriptor,pe=Object.getOwnPropertyDescriptors,ge=Object.getOwnPropertyNames,W=Object.getOwnPropertySymbols;var j=Object.prototype.hasOwnProperty,fe=Object.prototype.propertyIsEnumerable;var z=(e,t,o)=>t in e?v(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,J=(e,t)=>{for(var o in t||(t={}))j.call(t,o)&&z(e,o,t[o]);if(W)for(var o of W(t))fe.call(t,o)&&z(e,o,t[o]);return e},Z=(e,t)=>me(e,pe(t));var P=(e,t)=>()=>(e&&(t=e(e=0)),t);var Ee=(e,t)=>{for(var o in t)v(e,o,{get:t[o],enumerable:!0})},ye=(e,t,o,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let c of ge(t))!j.call(e,c)&&c!==o&&v(e,c,{get:()=>t[c],enumerable:!(a=de(t,c))||a.enumerable});return e};var he=e=>ye(v({},"__esModule",{value:!0}),e);function k(e,t){if(typeof __html__=="undefined")throw new Error("No UI defined");let o=`<div id="create-figma-plugin"></div><script>document.body.classList.add('theme-${figma.editorType}');const __FIGMA_COMMAND__='${typeof figma.command=="undefined"?"":figma.command}';const __SHOW_UI_DATA__=${JSON.stringify(typeof t=="undefined"?{}:t)};${__html__}</script>`;figma.showUI(o,Z(J({},e),{themeColors:typeof e.themeColors=="undefined"?!0:e.themeColors}))}var ee=P(()=>{});var te=P(()=>{ee()});var L,b,K=P(()=>{"use strict";L="Questline:",b=/^[a-z0-9-]+$/});function oe(e){return e.toLowerCase().trim().replace(/\s+/g,"-").replace(/[^a-z0-9-]/g,"")}function ne(e){return/\s{2,}/.test(e)}var se=P(()=>{"use strict"});var X,re=P(()=>{"use strict";X={MISSING_BG:`\u274C Missing Background Layer

Your questline frame needs a layer named "BG" that contains the background image.

How to fix:
1. Add a frame named "BG" inside your questline
2. Place your background image in this frame`,TOO_FEW_QUESTS:`\u274C Not Enough Quests

You need at least 3 quests in your questline.

How to fix:
1. Add more quest instances to your questline
2. Make sure each quest has a unique name`,TOO_MANY_QUESTS:`\u274C Too Many Quests

You can have a maximum of 20 quests in your questline.

How to fix:
1. Remove some quest instances
2. Keep only the quests you need`,DUPLICATE_QUEST_KEY:`\u274C Duplicate Quest Names

Two or more quests have the same name.

How to fix:
1. Give each quest a unique name
2. Check the "questKey" property in each quest instance`,INVALID_QUEST_KEY:`\u274C Invalid Quest Name

Quest names can only contain lowercase letters, numbers, and hyphens.

How to fix:
1. Use only lowercase letters (a-z)
2. Use numbers (0-9)
3. Use hyphens (-) instead of spaces
4. Examples: "quest-1", "daily-challenge", "bonus-round"`,QUEST_KEY_DOUBLE_WHITESPACE:`\u274C Invalid Quest Name

Quest name contains double spaces.

How to fix:
1. Remove extra spaces from the quest name
2. Use single spaces or hyphens instead`,QUEST_KEY_OUT_OF_BOUNDS:`\u274C Quest Positioned Outside Frame

This quest is positioned outside the questline frame.

How to fix:
1. Move the quest inside the questline frame
2. Make sure the entire quest is visible within the frame`,QUEST_KEY_NOT_INSIDE_PARENT:`\u274C Quest Not Fully Inside Frame

This quest extends beyond the questline frame boundaries.

How to fix:
1. Resize or reposition the quest
2. Make sure it fits completely within the frame`,QUEST_KEY_AUTO_LAYOUT_ENABLED:`\u274C Auto Layout Must Be Disabled

This quest has auto layout enabled, which can cause positioning issues.

How to fix:
1. Select the quest instance
2. In the right panel, turn off "Auto Layout"
3. Use absolute positioning instead`,MISSING_ACTIVE_VARIANT:`\u274C Missing Quest States

This quest component is missing required states.

How to fix:
1. Make sure your quest component has "locked", "active", "unclaimed", and "completed" states
2. The "active" state is mandatory
3. Check the component properties in Figma`,MISSING_QUEST_KEY:`\u274C Missing Quest Name

This quest doesn't have a name assigned.

How to fix:
1. Select the quest instance
2. In the right panel, find the "questKey" property
3. Enter a unique name for this quest`,IMAGE_EXPORT_FAILED:`\u274C Image Export Failed

One or more images couldn't be exported.

How to fix:
1. Make sure all images are properly placed in frames
2. Check that images are not corrupted
3. Try re-uploading the images in Figma`,VALIDATION_FAILED:`\u274C Validation Error

There's an issue with your questline structure.

How to fix:
1. Check that all quest names are unique
2. Make sure quest names follow the naming rules
3. Verify all quests are properly positioned`,UNKNOWN:`\u274C Unexpected Error

Something went wrong while processing your questline.

How to fix:
1. Try refreshing the plugin
2. Check that your Figma file is saved
3. Make sure you have the latest version of the plugin`}});function Se(e){return e.type==="GROUP"&&"componentProperties"in e&&typeof e.componentProperties=="object"}function H(e){return"fills"in e}function Ne(e){try{let t="",o=e.byteLength;for(let a=0;a<o;a++)t+=String.fromCharCode(e[a]);return btoa(t)}catch(t){console.log("EXPORT DEBUG: btoa failed, trying alternative base64 encoding");let o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a="",c=0;for(;c<e.length;){let h=e[c++],g=c<e.length?e[c++]:0,s=c<e.length?e[c++]:0,l=h>>2,f=(h&3)<<4|g>>4,I=(g&15)<<2|s>>6,G=s&63;a+=o[l]+o[f]+(c>e.length+1?"=":o[I])+(c>e.length?"=":o[G])}return a}}function $(e){return Array.isArray(e.fills)&&e.fills.find(t=>t.type==="IMAGE"&&!!t.imageHash)||null}function S(e){return"findAll"in e&&typeof e.findAll=="function"}function M(e){let t=[];return S(e)&&(t=e.findAll(o=>!H(o)||o.name!=="Image"?!1:(o.type==="FRAME"||o.type==="RECTANGLE"||o.type==="ELLIPSE"||o.type==="POLYGON"||o.type==="STAR"||o.type==="VECTOR"||o.type==="BOOLEAN_OPERATION"||o.type==="LINE")&&!!$(o))),t[0]||null}function Ae(e,t){if(!S(e))return null;let o=e.findOne(s=>s.name==="Visuals");if(!o||!("children"in o))return console.log("SCAN DEBUG: No Visuals frame found in quest",t),null;let a=o.children;console.log("SCAN DEBUG: Visuals frame children for quest",t,":",a.map(s=>s.name)),console.log("SCAN DEBUG: Children count:",a.length);let c=a.find(s=>s.name==="Image"),h=a.length>1,g=c&&h;return console.log("SCAN DEBUG: Analysis for quest",t,":"),console.log("  - Has Image child:",!!c),console.log("  - Has multiple elements:",h),console.log("  - Has Image + others:",g),console.log("  - All children names:",a.map(s=>s.name)),c&&!h?(console.log("SCAN DEBUG: Simple quest structure for",t,"- found Image frame"),{type:"simple",node:c,bounds:{x:c.x+o.x+e.x,y:c.y+o.y+e.y,width:c.width,height:c.height}}):h?(console.log("SCAN DEBUG: Complex quest structure for",t,"- found",a.length,"elements in Visuals"),console.log("SCAN DEBUG: Elements:",a.map(s=>s.name)),console.log("SCAN DEBUG: Will export entire Visuals frame for",t),{type:"complex",node:o,bounds:{x:o.x+e.x,y:o.y+e.y,width:o.width,height:o.height}}):(console.log("SCAN DEBUG: No valid quest structure found for",t),null)}function xe(e){if(!S(e))return null;let t=e.findOne(a=>a.name==="Properties");if(!t||!("children"in t))return console.log("SCAN DEBUG: No Properties group found"),null;let o=t.children.find(a=>a.type==="TEXT"&&a.name.toLowerCase().includes("questkey"));return o&&o.characters?(console.log("SCAN DEBUG: Found questKey:",o.characters),o.characters):(console.log("SCAN DEBUG: No questKey text found in Properties group"),null)}async function Y(){var G,w,R;console.log("SCAN DEBUG: scanQuestline started");let e=figma.currentPage.selection;console.log("SCAN DEBUG: got selection",e.length,e.map(n=>n.name));let t=[],o;if(e.length===0)return t.push({code:"UNKNOWN",message:"Please select a questline frame to scan.",level:"error"}),console.log("SCAN DEBUG: no selection"),V(t);let a=e.filter(n=>n.type==="FRAME"&&n.name.trim().toLowerCase().startsWith(L.toLowerCase()));if(console.log("SCAN DEBUG: selectedQuestlines",a.length,a.map(n=>n.name)),a.length===1)o=a[0],console.log("SCAN DEBUG: using selected questline",o.name);else return a.length>1?(t.push({code:"UNKNOWN",message:"Multiple questline frames selected. Please select only one questline frame.",level:"error"}),console.log("SCAN DEBUG: multiple questline frames selected, aborting"),V(t)):(t.push({code:"UNKNOWN",message:'Selected node is not a questline frame. Please select a frame named "Questline: <name>".',level:"error"}),console.log("SCAN DEBUG: no questline frame selected"),V(t));console.log("SCAN DEBUG: questline root found",o.name);let c=oe(o.name.replace(L,"")),h={width:o.width,height:o.height},g=o.findOne(n=>n.name.toLowerCase()==="bg"),s;g&&"exportAsync"in g&&(s=await y(g),s||(t.push({code:"IMAGE_EXPORT_FAILED",message:"Background image could not be exported. Please re-upload the image in Figma.",nodeId:g.id,level:"error"}),console.log("SCAN DEBUG: BG exportAsync failed"))),console.log("SCAN DEBUG: bg layer found?",!!g),console.log("SCAN DEBUG: root.children length",o.children.length);let l=[],f=new Set;console.log("SCAN DEBUG: Starting quest processing, root.children.length:",o.children.length);for(let n of o.children){console.log("SCAN DEBUG: child",n.name,n.type);let _=n.type==="INSTANCE"&&"componentProperties"in n||Se(n)&&"componentProperties"in n||n.type==="GROUP"&&Array.isArray(n.children)&&n.children.some(r=>r.type==="FRAME"&&r.name==="Image");if(console.log("SCAN DEBUG: isCandidate",_),!_)continue;let i="",O=xe(n);if(O)i=O,console.log("SCAN DEBUG: Found questKey using new structure:",i);else{if(n.type==="INSTANCE"&&"componentProperties"in n){for(let r of Object.keys(n.componentProperties))if(r.startsWith("questKey")){i=String(n.componentProperties[r].value);break}}else if(n.type==="GROUP"&&"componentProperties"in n){for(let r of Object.keys(n.componentProperties))if(r.startsWith("questKey")){i=String(n.componentProperties[r].value);break}}else if(n.type==="GROUP"&&Array.isArray(n.children)){let r=n.children.find(C=>C.type==="TEXT");r&&typeof r.characters=="string"&&(i=r.characters)}console.log("SCAN DEBUG: questKeyRaw (fallback):",i)}if(!i||i.trim()===""){t.push({code:"MISSING_QUEST_KEY",message:`Quest key is missing for node "${n.name}". Please add a questKey property.`,nodeId:n.id,level:"error"});continue}let u=i.trim();if(!b.test(u)){t.push({code:"INVALID_QUEST_KEY",message:`Invalid quest key "${u}". Must be lowercase, alphanumeric, with hyphens only.`,nodeId:n.id,level:"error"});continue}if(ne(u)){t.push({code:"QUEST_KEY_DOUBLE_WHITESPACE",message:`Quest key "${u}" contains double whitespace.`,nodeId:n.id,level:"error"});continue}if(f.has(u)){t.push({code:"DUPLICATE_QUEST_KEY",message:`Duplicate quest key "${u}". Each quest must have a unique name.`,nodeId:n.id,level:"error"});continue}f.add(u);let m=null,T=null,x=Ae(n,u);if(x?(m=x.node,T=x.bounds,console.log("SCAN DEBUG: Found quest elements using new structure:",x.type,"node:",m.name)):(n.type==="GROUP"&&Array.isArray(n.children)?(m=n.children.find(r=>H(r)&&r.name==="Image"&&!!$(r))||null,console.log("SCAN DEBUG: GROUP node children:",(G=n.children)==null?void 0:G.map(r=>({name:r.name,type:r.type,hasFills:H(r),hasImagePaint:!!$(r)})))):n.type==="INSTANCE"&&S(n)&&(m=M(n),console.log("SCAN DEBUG: INSTANCE node, findImageNode result:",m?m.name:"null")),m&&(T={x:m.x+n.x,y:m.y+n.y,width:m.width,height:m.height})),console.log("SCAN DEBUG: imageNode",m?m.name:null,m?m.type:null),!m||!T){console.log("SCAN DEBUG: No imageNode found for quest",u,"node:",n.name,"type:",n.type);continue}let d,E,U,N;console.log("SCAN DEBUG: about to export quest images for",i);try{if("exportAsync"in m){if(console.log("SCAN DEBUG: imageNode has exportAsync, attempting export"),(x==null?void 0:x.type)==="complex")if(console.log("SCAN DEBUG: Exporting complex quest for",i,"- using Visuals frame"),n.type==="INSTANCE"&&"componentProperties"in n){let r=n,C=(w=r.componentProperties.State)==null?void 0:w.value;try{r.setProperties({State:"locked"}),await new Promise(p=>setTimeout(p,100));let A=null;S(r)&&(A=r.findOne(p=>p.name==="Visuals")),A&&(d=await y(A),console.log("SCAN DEBUG: locked state export result for",i,":",d?"SUCCESS":"FAILED")),r.setProperties({State:"active"}),await new Promise(p=>setTimeout(p,100));let q=null;S(r)&&(q=r.findOne(p=>p.name==="Visuals")),q&&(E=await y(q),console.log("SCAN DEBUG: active state export result for",i,":",E?"SUCCESS":"FAILED")),r.setProperties({State:"unclaimed"}),await new Promise(p=>setTimeout(p,100));let B=null;S(r)&&(B=r.findOne(p=>p.name==="Visuals")),B&&(U=await y(B),console.log("SCAN DEBUG: unclaimed state export result for",i,":",U?"SUCCESS":"FAILED")),r.setProperties({State:"completed"}),await new Promise(p=>setTimeout(p,100));let D=null;S(r)&&(D=r.findOne(p=>p.name==="Visuals")),D?(N=await y(D),console.log("SCAN DEBUG: completed state export result for",i,":",N?"SUCCESS":"FAILED")):(console.log("SCAN DEBUG: could not find Visuals frame in completed state for",i),N=E),C&&r.setProperties({State:C})}catch(A){console.log("SCAN DEBUG: failed to export states for",i,A),d=await y(m),E=d,U=d,N=d}}else d=await y(m),E=d,U=d,N=d;else if(console.log("SCAN DEBUG: Exporting simple quest for",i,"- using Image frame"),n.type==="INSTANCE"&&"componentProperties"in n){let r=n,C=(R=r.componentProperties.State)==null?void 0:R.value;try{r.setProperties({State:"locked"}),await new Promise(p=>setTimeout(p,100));let A=null;S(r)&&(A=M(r)),A&&(d=await y(A),console.log("SCAN DEBUG: locked state export result for",i,":",d?"SUCCESS":"FAILED")),r.setProperties({State:"active"}),await new Promise(p=>setTimeout(p,100));let q=null;S(r)&&(q=M(r)),q&&(E=await y(q),console.log("SCAN DEBUG: active state export result for",i,":",E?"SUCCESS":"FAILED")),r.setProperties({State:"unclaimed"}),await new Promise(p=>setTimeout(p,100));let B=null;S(r)&&(B=M(r)),B&&(U=await y(B),console.log("SCAN DEBUG: unclaimed state export result for",i,":",U?"SUCCESS":"FAILED")),r.setProperties({State:"completed"}),await new Promise(p=>setTimeout(p,100));let D=null;S(r)&&(D=M(r)),D?(N=await y(D),console.log("SCAN DEBUG: completed state export result for",i,":",N?"SUCCESS":"FAILED")):(console.log("SCAN DEBUG: could not find image node in completed state for",i),N=E),C&&r.setProperties({State:C})}catch(A){console.log("SCAN DEBUG: failed to export states for",i,A),d=await y(m),E=d,U=d,N=d}}else d=await y(m),E=d,U=d,N=d;d?console.log("SCAN DEBUG: quest",i,"exportAsync succeeded, lockedImgUrl length:",d.length,"activeImgUrl length:",E==null?void 0:E.length):(t.push({code:"IMAGE_EXPORT_FAILED",message:"Quest image could not be exported. Please re-upload the image in Figma.",nodeId:n.id,level:"error"}),console.log("SCAN DEBUG: quest",i,"exportAsync failed, skipping export"))}else t.push({code:"IMAGE_EXPORT_FAILED",message:"Quest image node does not support export. Please use a Frame or Rectangle.",nodeId:n.id,level:"error"}),console.log("SCAN DEBUG: quest",i,"image node does not support exportAsync");console.log("SCAN DEBUG: finished quest image export",i)}catch(r){console.log("EXPORT DEBUG: quest",i,"image export error",r)}l.push({nodeId:n.id,questKey:u,x:T.x,y:T.y,w:T.width,h:T.height,rotation:m.rotation||0,lockedNodeId:m.id,activeNodeId:m.id,unclaimedNodeId:m.id,completedNodeId:m.id,lockedImgUrl:d,activeImgUrl:E,unclaimedImgUrl:U,completedImgUrl:N,isFlattened:(x==null?void 0:x.type)==="complex"}),console.log("SCAN DEBUG: quest added, total now",l.length),console.log("SCAN DEBUG: Added quest:",{questKey:u,nodeId:n.id,x:m.x+n.x,y:m.y+n.y})}console.log("SCAN DEBUG: Final quest count:",l.length),console.log("SCAN DEBUG: All quests:",l.map(n=>({questKey:n.questKey,nodeId:n.nodeId}))),l.length<3&&t.push({code:"TOO_FEW_QUESTS",message:X.TOO_FEW_QUESTS,nodeId:o.id,level:"error"}),l.length>20&&t.push({code:"TOO_MANY_QUESTS",message:X.TOO_MANY_QUESTS,nodeId:o.id,level:"error"});let I={questlineId:c,frameSize:h,backgroundNodeId:g?g.id:"",backgroundFillUrl:s,quests:l,issues:t};return console.log("SCAN DEBUG: returning scan result",I),I}function V(e){return{questlineId:"",frameSize:{width:0,height:0},backgroundNodeId:"",quests:[],issues:e}}async function y(e){if(console.log("EXPORT DEBUG: safeExportNodeAsPng called for",e.name,"type:",e.type),!("exportAsync"in e)){console.log("EXPORT DEBUG: node does not have exportAsync");return}try{console.log("EXPORT DEBUG: calling exportAsync on",e.name);let t=await e.exportAsync({format:"PNG"});console.log("EXPORT DEBUG: exportAsync succeeded for",e.name,"bytes:",t.length);let o=`data:image/png;base64,${Ne(t)}`;return console.log("EXPORT DEBUG: base64 conversion successful, result length:",o.length),o}catch(t){console.log("EXPORT DEBUG: exportAsync failed for",e.name,t);return}}var ie=P(()=>{"use strict";K();se();re()});async function ae(e){var h,g;console.log("EXPORT DEBUG: exportQuestline called with scan:",e);let t=[];if(e.issues.some(s=>s.level==="error"))return console.log("EXPORT DEBUG: Scan has errors, returning early"),{json:null,issues:e.issues};try{if(!b.test(e.questlineId))throw new Error("Invalid questlineId format");if(e.quests.length<3)throw new Error(`At least ${3} quests required`);if(e.quests.length>20)throw new Error(`No more than ${20} quests allowed`);let s=e.quests.map(f=>f.questKey.trim().toLowerCase());if(new Set(s).size!==s.length)throw new Error("Quest keys must be unique (case-insensitive, trimmed)");for(let f of e.quests){if(!b.test(f.questKey))throw new Error(`Invalid questKey format: ${f.questKey}`);if(/\s{2,}/.test(f.questKey))throw new Error(`Quest key cannot have double whitespace: ${f.questKey}`)}}catch(s){return t.push({code:"VALIDATION_FAILED",message:`Validation failed: ${s instanceof Error?s.message:"Unknown validation error"}`,level:"error"}),{json:null,issues:t}}let o=[];try{console.log("EXPORT DEBUG: Exporting background image...");let s=figma.getNodeById(e.backgroundNodeId);if(!s)throw new Error("Background node not found");let l=await s.exportAsync({format:"PNG"});console.log("EXPORT DEBUG: Background image exported, size:",l.length),o.push({name:"questline-bg.png",data:l})}catch(s){return console.log("EXPORT DEBUG: Background export failed:",s),t.push({code:"IMAGE_EXPORT_FAILED",message:`Background image could not be exported: ${s instanceof Error?s.message:"Unknown error"}`,level:"error"}),{json:null,issues:t}}let a=[];for(let s of e.quests){try{let l=figma.getNodeById(s.nodeId);if(!l||l.type!=="INSTANCE")throw new Error("Quest instance not found");let f=(g=(h=l.componentProperties)==null?void 0:h.State)==null?void 0:g.value;l.setProperties({State:"locked"}),await new Promise(u=>setTimeout(u,100));let I=null;if("findAll"in l&&(I=l.findOne(u=>u.type==="FRAME"&&u.name==="Image")),!I||!("exportAsync"in I))throw new Error("Image frame not found for locked state");let G=await I.exportAsync({format:"PNG"});console.log("EXPORT DEBUG: Quest locked image exported for",s.questKey,"size:",G.length),o.push({name:`quest-${s.questKey}-locked.png`,data:G}),l.setProperties({State:"active"}),await new Promise(u=>setTimeout(u,100));let w=null;if("findAll"in l&&(w=l.findOne(u=>u.type==="FRAME"&&u.name==="Image")),!w||!("exportAsync"in w))throw new Error("Image frame not found for active state");let R=await w.exportAsync({format:"PNG"});console.log("EXPORT DEBUG: Quest active image exported for",s.questKey,"size:",R.length),o.push({name:`quest-${s.questKey}-active.png`,data:R}),l.setProperties({State:"unclaimed"}),await new Promise(u=>setTimeout(u,100));let n=null;if("findAll"in l&&(n=l.findOne(u=>u.type==="FRAME"&&u.name==="Image")),!n||!("exportAsync"in n))throw new Error("Image frame not found for unclaimed state");let _=await n.exportAsync({format:"PNG"});console.log("EXPORT DEBUG: Quest unclaimed image exported for",s.questKey,"size:",_.length),o.push({name:`quest-${s.questKey}-unclaimed.png`,data:_}),l.setProperties({State:"completed"}),await new Promise(u=>setTimeout(u,100));let i=null;if("findAll"in l&&(i=l.findOne(u=>u.type==="FRAME"&&u.name==="Image")),!i||!("exportAsync"in i))throw new Error("Image frame not found for completed state");let O=await i.exportAsync({format:"PNG"});console.log("EXPORT DEBUG: Quest completed image exported for",s.questKey,"size:",O.length),o.push({name:`quest-${s.questKey}-completed.png`,data:O}),f&&l.setProperties({State:f})}catch(l){return t.push({code:"IMAGE_EXPORT_FAILED",message:`Quest image export failed for ${s.questKey}: ${l instanceof Error?l.message:"Unknown error"}`,nodeId:s.nodeId,level:"error"}),{json:null,issues:t}}a.push({questKey:s.questKey,x:s.x,y:s.y,w:s.w,h:s.h,rotation:s.rotation,lockedImg:`quest-${s.questKey}-locked.png`,activeImg:`quest-${s.questKey}-active.png`,unclaimedImg:`quest-${s.questKey}-unclaimed.png`,completedImg:`quest-${s.questKey}-completed.png`})}let c={questlineId:e.questlineId,frameSize:e.frameSize,background:{exportUrl:"questline-bg.png"},quests:a};return console.log("EXPORT DEBUG: Sending",o.length,"images + JSON for folder selection"),figma.ui.postMessage({type:"EXPORT_WITH_FOLDER",questlineId:e.questlineId,images:o,json:c}),{json:c,issues:t}}var le=P(()=>{"use strict";K()});var ue={};Ee(ue,{default:()=>Ie});function Ie(){k({height:700,width:1100}),figma.ui.onmessage=async e=>{if(e.type==="SCAN"){figma.ui.postMessage({type:"SCAN_PROGRESS",progress:10});let t=await Y();figma.ui.postMessage({type:"SCAN_PROGRESS",progress:100}),figma.ui.postMessage({type:"SCAN_RESULT",data:t})}else if(e.type==="EXPORT"){console.log("EXPORT DEBUG: Starting export...");try{let t;if(e.scan?(t=e.scan,console.log("EXPORT DEBUG: Using existing scan result")):(console.log("EXPORT DEBUG: No scan provided, scanning..."),t=await Y()),console.log("EXPORT DEBUG: Scan result:",t),t.issues.some(a=>a.level==="error")){console.log("EXPORT DEBUG: Scan has errors, aborting export"),figma.ui.postMessage({type:"EXPORT_RESULT",data:{json:null,issues:t.issues}});return}console.log("EXPORT DEBUG: Calling exportQuestline...");let o=await ae(t);console.log("EXPORT DEBUG: Export result:",o),figma.ui.postMessage({type:"EXPORT_RESULT",data:o})}catch(t){console.log("EXPORT DEBUG: Export failed with error:",t),figma.ui.postMessage({type:"EXPORT_RESULT",data:{json:null,issues:[{code:"UNKNOWN",message:`Export failed: ${t instanceof Error?t.message:"Unknown error"}`,level:"error"}]}})}}else e.type==="RESIZE"&&figma.ui.resize(e.width,e.height)}}var ce=P(()=>{"use strict";te();ie();le()});var Ue={"src/main/index.ts--default":(ce(),he(ue)).default},Pe="src/main/index.ts--default";Ue[Pe]();
