var R=Object.defineProperty,ue=Object.defineProperties,ce=Object.getOwnPropertyDescriptor,de=Object.getOwnPropertyDescriptors,me=Object.getOwnPropertyNames,$=Object.getOwnPropertySymbols;var W=Object.prototype.hasOwnProperty,pe=Object.prototype.propertyIsEnumerable;var Y=(e,o,t)=>o in e?R(e,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[o]=t,j=(e,o)=>{for(var t in o||(o={}))W.call(o,t)&&Y(e,t,o[t]);if($)for(var t of $(o))pe.call(o,t)&&Y(e,t,o[t]);return e},z=(e,o)=>ue(e,de(o));var U=(e,o)=>()=>(e&&(o=e(e=0)),o);var ge=(e,o)=>{for(var t in o)R(e,t,{get:o[t],enumerable:!0})},fe=(e,o,t,a)=>{if(o&&typeof o=="object"||typeof o=="function")for(let u of me(o))!W.call(e,u)&&u!==t&&R(e,u,{get:()=>o[u],enumerable:!(a=ce(o,u))||a.enumerable});return e};var Ee=e=>fe(R({},"__esModule",{value:!0}),e);function Q(e,o){if(typeof __html__=="undefined")throw new Error("No UI defined");let t=`<div id="create-figma-plugin"></div><script>document.body.classList.add('theme-${figma.editorType}');const __FIGMA_COMMAND__='${typeof figma.command=="undefined"?"":figma.command}';const __SHOW_UI_DATA__=${JSON.stringify(typeof o=="undefined"?{}:o)};${__html__}</script>`;figma.showUI(t,z(j({},e),{themeColors:typeof e.themeColors=="undefined"?!0:e.themeColors}))}var J=U(()=>{});var Z=U(()=>{J()});var k,_,F=U(()=>{"use strict";k="Questline:",_=/^[a-z0-9-]+$/});function ee(e){return e.toLowerCase().trim().replace(/\s+/g,"-").replace(/[^a-z0-9-]/g,"")}function oe(e){return/\s{2,}/.test(e)}var te=U(()=>{"use strict"});var v,ne=U(()=>{"use strict";v={MISSING_BG:`\u274C Missing Background Layer

Your questline frame needs a layer named "BG" that contains the background image.

How to fix:
1. Add a frame named "BG" inside your questline
2. Place your background image in this frame`,TOO_FEW_QUESTS:`\u274C Not Enough Quests

You need at least 3 quests in your questline.

How to fix:
1. Add more quest instances to your questline
2. Make sure each quest has a unique name`,TOO_MANY_QUESTS:`\u274C Too Many Quests

You can have a maximum of 20 quests in your questline.

How to fix:
1. Remove some quest instances
2. Keep only the quests you need`,DUPLICATE_QUEST_KEY:`\u274C Duplicate Quest Names

Two or more quests have the same name.

How to fix:
1. Give each quest a unique name
2. Check the "questKey" property in each quest instance`,INVALID_QUEST_KEY:`\u274C Invalid Quest Name

Quest names can only contain lowercase letters, numbers, and hyphens.

How to fix:
1. Use only lowercase letters (a-z)
2. Use numbers (0-9)
3. Use hyphens (-) instead of spaces
4. Examples: "quest-1", "daily-challenge", "bonus-round"`,QUEST_KEY_DOUBLE_WHITESPACE:`\u274C Invalid Quest Name

Quest name contains double spaces.

How to fix:
1. Remove extra spaces from the quest name
2. Use single spaces or hyphens instead`,QUEST_KEY_OUT_OF_BOUNDS:`\u274C Quest Positioned Outside Frame

This quest is positioned outside the questline frame.

How to fix:
1. Move the quest inside the questline frame
2. Make sure the entire quest is visible within the frame`,QUEST_KEY_NOT_INSIDE_PARENT:`\u274C Quest Not Fully Inside Frame

This quest extends beyond the questline frame boundaries.

How to fix:
1. Resize or reposition the quest
2. Make sure it fits completely within the frame`,QUEST_KEY_AUTO_LAYOUT_ENABLED:`\u274C Auto Layout Must Be Disabled

This quest has auto layout enabled, which can cause positioning issues.

How to fix:
1. Select the quest instance
2. In the right panel, turn off "Auto Layout"
3. Use absolute positioning instead`,MISSING_DONE_VARIANT:`\u274C Missing Quest States

This quest component is missing required states.

How to fix:
1. Make sure your quest component has "locked", "closed", and "open" states
2. Check the component properties in Figma`,MISSING_QUEST_KEY:`\u274C Missing Quest Name

This quest doesn't have a name assigned.

How to fix:
1. Select the quest instance
2. In the right panel, find the "questKey" property
3. Enter a unique name for this quest`,IMAGE_EXPORT_FAILED:`\u274C Image Export Failed

One or more images couldn't be exported.

How to fix:
1. Make sure all images are properly placed in frames
2. Check that images are not corrupted
3. Try re-uploading the images in Figma`,VALIDATION_FAILED:`\u274C Validation Error

There's an issue with your questline structure.

How to fix:
1. Check that all quest names are unique
2. Make sure quest names follow the naming rules
3. Verify all quests are properly positioned`,UNKNOWN:`\u274C Unexpected Error

Something went wrong while processing your questline.

How to fix:
1. Try refreshing the plugin
2. Check that your Figma file is saved
3. Make sure you have the latest version of the plugin`}});function ye(e){return e.type==="GROUP"&&"componentProperties"in e&&typeof e.componentProperties=="object"}function K(e){return"fills"in e}function he(e){try{let o="",t=e.byteLength;for(let a=0;a<t;a++)o+=String.fromCharCode(e[a]);return btoa(o)}catch(o){console.log("EXPORT DEBUG: btoa failed, trying alternative base64 encoding");let t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a="",u=0;for(;u<e.length;){let E=e[u++],p=u<e.length?e[u++]:0,s=u<e.length?e[u++]:0,l=E>>2,g=(E&3)<<4|p>>4,x=(p&15)<<2|s>>6,G=s&63;a+=t[l]+t[g]+(u>e.length+1?"=":t[x])+(u>e.length?"=":t[G])}return a}}function X(e){return Array.isArray(e.fills)&&e.fills.find(o=>o.type==="IMAGE"&&!!o.imageHash)||null}function A(e){return"findAll"in e&&typeof e.findAll=="function"}function O(e){let o=[];return A(e)&&(o=e.findAll(t=>!K(t)||t.name!=="Image"?!1:(t.type==="FRAME"||t.type==="RECTANGLE"||t.type==="ELLIPSE"||t.type==="POLYGON"||t.type==="STAR"||t.type==="VECTOR"||t.type==="BOOLEAN_OPERATION"||t.type==="LINE")&&!!X(t))),o[0]||null}function Se(e,o){if(!A(e))return null;let t=e.findOne(s=>s.name==="Visuals");if(!t||!("children"in t))return console.log("SCAN DEBUG: No Visuals frame found in quest",o),null;let a=t.children;console.log("SCAN DEBUG: Visuals frame children for quest",o,":",a.map(s=>s.name)),console.log("SCAN DEBUG: Children count:",a.length);let u=a.find(s=>s.name==="Image"),E=a.length>1,p=u&&E;return console.log("SCAN DEBUG: Analysis for quest",o,":"),console.log("  - Has Image child:",!!u),console.log("  - Has multiple elements:",E),console.log("  - Has Image + others:",p),console.log("  - All children names:",a.map(s=>s.name)),u&&!E?(console.log("SCAN DEBUG: Simple quest structure for",o,"- found Image frame"),{type:"simple",node:u,bounds:{x:u.x+t.x+e.x,y:u.y+t.y+e.y,width:u.width,height:u.height}}):E?(console.log("SCAN DEBUG: Complex quest structure for",o,"- found",a.length,"elements in Visuals"),console.log("SCAN DEBUG: Elements:",a.map(s=>s.name)),console.log("SCAN DEBUG: Will export entire Visuals frame for",o),{type:"complex",node:t,bounds:{x:t.x+e.x,y:t.y+e.y,width:t.width,height:t.height}}):(console.log("SCAN DEBUG: No valid quest structure found for",o),null)}function Ne(e){if(!A(e))return null;let o=e.findOne(a=>a.name==="Properties");if(!o||!("children"in o))return console.log("SCAN DEBUG: No Properties group found"),null;let t=o.children.find(a=>a.type==="TEXT"&&a.name.toLowerCase().includes("questkey"));return t&&t.characters?(console.log("SCAN DEBUG: Found questKey:",t.characters),t.characters):(console.log("SCAN DEBUG: No questKey text found in Properties group"),null)}async function V(){var G,P,B;console.log("SCAN DEBUG: scanQuestline started");let e=figma.currentPage.selection;console.log("SCAN DEBUG: got selection",e.length,e.map(n=>n.name));let o=[],t;if(e.length===0)return o.push({code:"UNKNOWN",message:"Please select a questline frame to scan.",level:"error"}),console.log("SCAN DEBUG: no selection"),L(o);let a=e.filter(n=>n.type==="FRAME"&&n.name.trim().toLowerCase().startsWith(k.toLowerCase()));if(console.log("SCAN DEBUG: selectedQuestlines",a.length,a.map(n=>n.name)),a.length===1)t=a[0],console.log("SCAN DEBUG: using selected questline",t.name);else return a.length>1?(o.push({code:"UNKNOWN",message:"Multiple questline frames selected. Please select only one questline frame.",level:"error"}),console.log("SCAN DEBUG: multiple questline frames selected, aborting"),L(o)):(o.push({code:"UNKNOWN",message:'Selected node is not a questline frame. Please select a frame named "Questline: <name>".',level:"error"}),console.log("SCAN DEBUG: no questline frame selected"),L(o));console.log("SCAN DEBUG: questline root found",t.name);let u=ee(t.name.replace(k,"")),E={width:t.width,height:t.height},p=t.findOne(n=>n.name.toLowerCase()==="bg"),s;p&&"exportAsync"in p&&(s=await S(p),s||(o.push({code:"IMAGE_EXPORT_FAILED",message:"Background image could not be exported. Please re-upload the image in Figma.",nodeId:p.id,level:"error"}),console.log("SCAN DEBUG: BG exportAsync failed"))),console.log("SCAN DEBUG: bg layer found?",!!p),console.log("SCAN DEBUG: root.children length",t.children.length);let l=[],g=new Set;console.log("SCAN DEBUG: Starting quest processing, root.children.length:",t.children.length);for(let n of t.children){console.log("SCAN DEBUG: child",n.name,n.type);let D=n.type==="INSTANCE"&&"componentProperties"in n||ye(n)&&"componentProperties"in n||n.type==="GROUP"&&Array.isArray(n.children)&&n.children.some(r=>r.type==="FRAME"&&r.name==="Image");if(console.log("SCAN DEBUG: isCandidate",D),!D)continue;let i="",H=Ne(n);if(H)i=H,console.log("SCAN DEBUG: Found questKey using new structure:",i);else{if(n.type==="INSTANCE"&&"componentProperties"in n){for(let r of Object.keys(n.componentProperties))if(r.startsWith("questKey")){i=String(n.componentProperties[r].value);break}}else if(n.type==="GROUP"&&"componentProperties"in n){for(let r of Object.keys(n.componentProperties))if(r.startsWith("questKey")){i=String(n.componentProperties[r].value);break}}else if(n.type==="GROUP"&&Array.isArray(n.children)){let r=n.children.find(w=>w.type==="TEXT");r&&typeof r.characters=="string"&&(i=r.characters)}console.log("SCAN DEBUG: questKeyRaw (fallback):",i)}if(!i||i.trim()===""){o.push({code:"MISSING_QUEST_KEY",message:`Quest key is missing for node "${n.name}". Please add a questKey property.`,nodeId:n.id,level:"error"});continue}let y=i.trim();if(!_.test(y)){o.push({code:"INVALID_QUEST_KEY",message:`Invalid quest key "${y}". Must be lowercase, alphanumeric, with hyphens only.`,nodeId:n.id,level:"error"});continue}if(oe(y)){o.push({code:"QUEST_KEY_DOUBLE_WHITESPACE",message:`Quest key "${y}" contains double whitespace.`,nodeId:n.id,level:"error"});continue}if(g.has(y)){o.push({code:"DUPLICATE_QUEST_KEY",message:`Duplicate quest key "${y}". Each quest must have a unique name.`,nodeId:n.id,level:"error"});continue}g.add(y);let c=null,T=null,N=Se(n,y);if(N?(c=N.node,T=N.bounds,console.log("SCAN DEBUG: Found quest elements using new structure:",N.type,"node:",c.name)):(n.type==="GROUP"&&Array.isArray(n.children)?(c=n.children.find(r=>K(r)&&r.name==="Image"&&!!X(r))||null,console.log("SCAN DEBUG: GROUP node children:",(G=n.children)==null?void 0:G.map(r=>({name:r.name,type:r.type,hasFills:K(r),hasImagePaint:!!X(r)})))):n.type==="INSTANCE"&&A(n)&&(c=O(n),console.log("SCAN DEBUG: INSTANCE node, findImageNode result:",c?c.name:"null")),c&&(T={x:c.x+n.x,y:c.y+n.y,width:c.width,height:c.height})),console.log("SCAN DEBUG: imageNode",c?c.name:null,c?c.type:null),!c||!T){console.log("SCAN DEBUG: No imageNode found for quest",y,"node:",n.name,"type:",n.type);continue}let d,I,f;console.log("SCAN DEBUG: about to export quest images for",i);try{if("exportAsync"in c){if(console.log("SCAN DEBUG: imageNode has exportAsync, attempting export"),(N==null?void 0:N.type)==="complex")if(console.log("SCAN DEBUG: Exporting complex quest for",i,"- using Visuals frame"),n.type==="INSTANCE"&&"componentProperties"in n){let r=n,w=(P=r.componentProperties.State)==null?void 0:P.value;try{r.setProperties({State:"locked"}),await new Promise(m=>setTimeout(m,100));let h=null;A(r)&&(h=r.findOne(m=>m.name==="Visuals")),h&&(d=await S(h),console.log("SCAN DEBUG: locked state export result for",i,":",d?"SUCCESS":"FAILED")),r.setProperties({State:"closed"}),await new Promise(m=>setTimeout(m,100));let C=null;A(r)&&(C=r.findOne(m=>m.name==="Visuals")),C&&(I=await S(C),console.log("SCAN DEBUG: closed state export result for",i,":",I?"SUCCESS":"FAILED")),r.setProperties({State:"open"}),await new Promise(m=>setTimeout(m,100));let q=null;A(r)&&(q=r.findOne(m=>m.name==="Visuals")),q?(f=await S(q),console.log("SCAN DEBUG: open state export result for",i,":",f?"SUCCESS":"FAILED")):(console.log("SCAN DEBUG: could not find Visuals frame in open state for",i),f=d),w&&r.setProperties({State:w})}catch(h){console.log("SCAN DEBUG: failed to export states for",i,h),d=await S(c),I=d,f=d}}else d=await S(c),I=d,f=d;else if(console.log("SCAN DEBUG: Exporting simple quest for",i,"- using Image frame"),n.type==="INSTANCE"&&"componentProperties"in n){let r=n,w=(B=r.componentProperties.State)==null?void 0:B.value;try{r.setProperties({State:"locked"}),await new Promise(m=>setTimeout(m,100));let h=null;A(r)&&(h=O(r)),h&&(d=await S(h),console.log("SCAN DEBUG: locked state export result for",i,":",d?"SUCCESS":"FAILED")),r.setProperties({State:"closed"}),await new Promise(m=>setTimeout(m,100));let C=null;A(r)&&(C=O(r)),C&&(I=await S(C),console.log("SCAN DEBUG: closed state export result for",i,":",I?"SUCCESS":"FAILED")),r.setProperties({State:"open"}),await new Promise(m=>setTimeout(m,100));let q=null;A(r)&&(q=O(r)),q?(f=await S(q),console.log("SCAN DEBUG: open state export result for",i,":",f?"SUCCESS":"FAILED")):(console.log("SCAN DEBUG: could not find image node in open state for",i),f=d),w&&r.setProperties({State:w})}catch(h){console.log("SCAN DEBUG: failed to export states for",i,h),d=await S(c),I=d,f=d}}else d=await S(c),I=d,f=d;d?console.log("SCAN DEBUG: quest",i,"exportAsync succeeded, lockedImgUrl length:",d.length,"doneImgUrl length:",f==null?void 0:f.length):(o.push({code:"IMAGE_EXPORT_FAILED",message:"Quest image could not be exported. Please re-upload the image in Figma.",nodeId:n.id,level:"error"}),console.log("SCAN DEBUG: quest",i,"exportAsync failed, skipping export"))}else o.push({code:"IMAGE_EXPORT_FAILED",message:"Quest image node does not support export. Please use a Frame or Rectangle.",nodeId:n.id,level:"error"}),console.log("SCAN DEBUG: quest",i,"image node does not support exportAsync");console.log("SCAN DEBUG: finished quest image export",i)}catch(r){console.log("EXPORT DEBUG: quest",i,"image export error",r)}l.push({nodeId:n.id,questKey:y,x:T.x,y:T.y,w:T.width,h:T.height,rotation:c.rotation||0,lockedNodeId:c.id,closedNodeId:c.id,doneNodeId:c.id,lockedImgUrl:d,closedImgUrl:I,doneImgUrl:f,isFlattened:(N==null?void 0:N.type)==="complex"}),console.log("SCAN DEBUG: quest added, total now",l.length),console.log("SCAN DEBUG: Added quest:",{questKey:y,nodeId:n.id,x:c.x+n.x,y:c.y+n.y})}console.log("SCAN DEBUG: Final quest count:",l.length),console.log("SCAN DEBUG: All quests:",l.map(n=>({questKey:n.questKey,nodeId:n.nodeId}))),l.length<3&&o.push({code:"TOO_FEW_QUESTS",message:v.TOO_FEW_QUESTS,nodeId:t.id,level:"error"}),l.length>20&&o.push({code:"TOO_MANY_QUESTS",message:v.TOO_MANY_QUESTS,nodeId:t.id,level:"error"});let x={questlineId:u,frameSize:E,backgroundNodeId:p?p.id:"",backgroundFillUrl:s,quests:l,issues:o};return console.log("SCAN DEBUG: returning scan result",x),x}function L(e){return{questlineId:"",frameSize:{width:0,height:0},backgroundNodeId:"",quests:[],issues:e}}async function S(e){if(console.log("EXPORT DEBUG: safeExportNodeAsPng called for",e.name,"type:",e.type),!("exportAsync"in e)){console.log("EXPORT DEBUG: node does not have exportAsync");return}try{console.log("EXPORT DEBUG: calling exportAsync on",e.name);let o=await e.exportAsync({format:"PNG"});console.log("EXPORT DEBUG: exportAsync succeeded for",e.name,"bytes:",o.length);let t=`data:image/png;base64,${he(o)}`;return console.log("EXPORT DEBUG: base64 conversion successful, result length:",t.length),t}catch(o){console.log("EXPORT DEBUG: exportAsync failed for",e.name,o);return}}var se=U(()=>{"use strict";F();te();ne()});async function re(e){var E,p;console.log("EXPORT DEBUG: exportQuestline called with scan:",e);let o=[];if(e.issues.some(s=>s.level==="error"))return console.log("EXPORT DEBUG: Scan has errors, returning early"),{json:null,issues:e.issues};try{if(!_.test(e.questlineId))throw new Error("Invalid questlineId format");if(e.quests.length<3)throw new Error(`At least ${3} quests required`);if(e.quests.length>20)throw new Error(`No more than ${20} quests allowed`);let s=e.quests.map(g=>g.questKey.trim().toLowerCase());if(new Set(s).size!==s.length)throw new Error("Quest keys must be unique (case-insensitive, trimmed)");for(let g of e.quests){if(!_.test(g.questKey))throw new Error(`Invalid questKey format: ${g.questKey}`);if(/\s{2,}/.test(g.questKey))throw new Error(`Quest key cannot have double whitespace: ${g.questKey}`)}}catch(s){return o.push({code:"VALIDATION_FAILED",message:`Validation failed: ${s instanceof Error?s.message:"Unknown validation error"}`,level:"error"}),{json:null,issues:o}}let t=[];try{console.log("EXPORT DEBUG: Exporting background image...");let s=figma.getNodeById(e.backgroundNodeId);if(!s)throw new Error("Background node not found");let l=await s.exportAsync({format:"PNG"});console.log("EXPORT DEBUG: Background image exported, size:",l.length),t.push({name:"questline-bg.png",data:l})}catch(s){return console.log("EXPORT DEBUG: Background export failed:",s),o.push({code:"IMAGE_EXPORT_FAILED",message:`Background image could not be exported: ${s instanceof Error?s.message:"Unknown error"}`,level:"error"}),{json:null,issues:o}}let a=[];for(let s of e.quests){try{let l=figma.getNodeById(s.nodeId);if(!l||l.type!=="INSTANCE")throw new Error("Quest instance not found");let g=(p=(E=l.componentProperties)==null?void 0:E.State)==null?void 0:p.value;l.setProperties({State:"locked"}),await new Promise(i=>setTimeout(i,100));let x=null;if("findAll"in l&&(x=l.findOne(i=>i.type==="FRAME"&&i.name==="Image")),!x||!("exportAsync"in x))throw new Error("Image frame not found for locked state");let G=await x.exportAsync({format:"PNG"});console.log("EXPORT DEBUG: Quest locked image exported for",s.questKey,"size:",G.length),t.push({name:`quest-${s.questKey}-locked.png`,data:G}),l.setProperties({State:"closed"}),await new Promise(i=>setTimeout(i,100));let P=null;if("findAll"in l&&(P=l.findOne(i=>i.type==="FRAME"&&i.name==="Image")),!P||!("exportAsync"in P))throw new Error("Image frame not found for closed state");let B=await P.exportAsync({format:"PNG"});console.log("EXPORT DEBUG: Quest closed image exported for",s.questKey,"size:",B.length),t.push({name:`quest-${s.questKey}-closed.png`,data:B}),l.setProperties({State:"open"}),await new Promise(i=>setTimeout(i,100));let n=null;if("findAll"in l&&(n=l.findOne(i=>i.type==="FRAME"&&i.name==="Image")),!n||!("exportAsync"in n))throw new Error("Image frame not found for open state");let D=await n.exportAsync({format:"PNG"});console.log("EXPORT DEBUG: Quest done image exported for",s.questKey,"size:",D.length),t.push({name:`quest-${s.questKey}-done.png`,data:D}),g&&l.setProperties({State:g})}catch(l){return o.push({code:"IMAGE_EXPORT_FAILED",message:`Quest image export failed for ${s.questKey}: ${l instanceof Error?l.message:"Unknown error"}`,nodeId:s.nodeId,level:"error"}),{json:null,issues:o}}a.push({questKey:s.questKey,x:s.x,y:s.y,w:s.w,h:s.h,rotation:s.rotation,lockedImg:`quest-${s.questKey}-locked.png`,closedImg:`quest-${s.questKey}-closed.png`,doneImg:`quest-${s.questKey}-done.png`})}let u={questlineId:e.questlineId,frameSize:e.frameSize,background:{exportUrl:"questline-bg.png"},quests:a};return console.log("EXPORT DEBUG: Sending",t.length,"images + JSON for folder selection"),figma.ui.postMessage({type:"EXPORT_WITH_FOLDER",questlineId:e.questlineId,images:t,json:u}),{json:u,issues:o}}var ie=U(()=>{"use strict";F()});var ae={};ge(ae,{default:()=>Ae});function Ae(){Q({height:700,width:1100}),figma.ui.onmessage=async e=>{if(e.type==="SCAN"){figma.ui.postMessage({type:"SCAN_PROGRESS",progress:10});let o=await V();figma.ui.postMessage({type:"SCAN_PROGRESS",progress:100}),figma.ui.postMessage({type:"SCAN_RESULT",data:o})}else if(e.type==="EXPORT"){console.log("EXPORT DEBUG: Starting export...");try{let o;if(e.scan?(o=e.scan,console.log("EXPORT DEBUG: Using existing scan result")):(console.log("EXPORT DEBUG: No scan provided, scanning..."),o=await V()),console.log("EXPORT DEBUG: Scan result:",o),o.issues.some(a=>a.level==="error")){console.log("EXPORT DEBUG: Scan has errors, aborting export"),figma.ui.postMessage({type:"EXPORT_RESULT",data:{json:null,issues:o.issues}});return}console.log("EXPORT DEBUG: Calling exportQuestline...");let t=await re(o);console.log("EXPORT DEBUG: Export result:",t),figma.ui.postMessage({type:"EXPORT_RESULT",data:t})}catch(o){console.log("EXPORT DEBUG: Export failed with error:",o),figma.ui.postMessage({type:"EXPORT_RESULT",data:{json:null,issues:[{code:"UNKNOWN",message:`Export failed: ${o instanceof Error?o.message:"Unknown error"}`,level:"error"}]}})}}else e.type==="RESIZE"&&figma.ui.resize(e.width,e.height)}}var le=U(()=>{"use strict";Z();se();ie()});var xe={"src/main/index.ts--default":(le(),Ee(ae)).default},Ie="src/main/index.ts--default";xe[Ie]();
